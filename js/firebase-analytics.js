/**
 * Firebase analytics module for TicTacToeExtreme
 * This module handles tracking page views, unique visitors, and game events
 */
const Analytics = (function() {
    let db;
    let initialized = false;
    
    // Storage key for client ID
    const CLIENT_ID_KEY = 'tictactoeExtreme_clientId';
    
    // Initialize Firebase
    async function initialize() {
        if (initialized) return true;
        
        try {
            console.log('Initializing Firebase Analytics...');
            
            // Check if firebaseConfig is available
            if (typeof firebaseConfig === 'undefined') {
                console.error('Firebase config is not defined! Check if firebase-config.js is loaded.');
                return false;
            }
            
            console.log('Firebase config found:', JSON.stringify({
                projectId: firebaseConfig.projectId || 'missing',
                apiKeyLength: firebaseConfig.apiKey ? firebaseConfig.apiKey.length : 0
            }));
            
            // Initialize Firebase with config
            // Note: firebaseConfig is defined in the separate firebase-config.js file
            // that is generated by GitHub Actions from repository secrets
            firebase.initializeApp(firebaseConfig);
            
            // Initialize App Check with reCAPTCHA v3
            try {
                console.log('Initializing Firebase App Check...');
                if (typeof firebase.appCheck !== 'undefined') {
                    const appCheck = firebase.appCheck();
                    appCheck.activate(
                        '6LcSxfEqAAAAABGUgiC-rWMpnVmt8XWvvR-uu7Cu',
                        true // Set to true for debug tokens in non-production environments
                    );
                    console.log('Firebase App Check initialized successfully');
                } else {
                    console.warn('Firebase App Check function not available');
                }
            } catch (appCheckError) {
                console.error('Error initializing App Check:', appCheckError);
                // Continue execution even if App Check fails
            }
            
            db = firebase.firestore();
            
            // Test connection to Firestore
            try {
                await db.collection('test').doc('test').set({
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    test: true
                });
                console.log('Successfully wrote test document to Firestore');
            } catch (firestoreError) {
                console.error('Error writing to Firestore:', firestoreError);
                throw firestoreError;
            }
            
            initialized = true;
            console.log('Firebase Analytics initialized successfully');
            
            // Track the page view once initialized
            trackPageView();
            
            return true;
        } catch (error) {
            console.error('Failed to initialize Firebase:', error);
            return false;
        }
    }
    
    // Generate or retrieve client ID for tracking unique visitors
    function getClientId() {
        let clientId = localStorage.getItem(CLIENT_ID_KEY);
        if (!clientId) {
            clientId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            localStorage.setItem(CLIENT_ID_KEY, clientId);
        }
        return clientId;
    }
    
    // Track page view
    async function trackPageView() {
        if (!initialized) {
            await initialize();
        }
        
        if (!initialized) return; // Skip if initialization failed
        
        try {
            const clientId = getClientId();
            const today = new Date().toISOString().split('T')[0];
            
            // Record daily visit
            await db.collection('metrics').doc('daily-counts').set({
                [today]: firebase.firestore.FieldValue.increment(1)
            }, { merge: true });
            
            // Record unique visitor (only count once per day per client)
            const visitorKey = `${today}_${clientId}`;
            const visitorRef = db.collection('visits').doc(visitorKey);
            const visitorDoc = await visitorRef.get();
            
            if (!visitorDoc.exists) {
                // First visit today from this client
                await visitorRef.set({
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    clientId: clientId,
                    date: today
                });
                
                // Increment unique visitor count
                await db.collection('metrics').doc('unique-daily').set({
                    [today]: firebase.firestore.FieldValue.increment(1)
                }, { merge: true });
            }
        } catch (error) {
            console.error('Error tracking page view:', error);
        }
    }
    
    // Track game events like game starts, completions, wins/losses
    async function trackGameEvent(eventType, eventData = {}) {
        if (!initialized) {
            await initialize();
        }
        
        if (!initialized) return; // Skip if initialization failed
        
        try {
            await db.collection('events').add({
                type: eventType,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                clientId: getClientId(),
                ...eventData
            });
        } catch (error) {
            console.error('Error tracking game event:', error);
        }
    }
    
    // Calculate win streak from game events
    async function calculateWinStreak(period = 'all') {
        try {
            // Get time period filter dates
            const now = new Date();
            let periodStart = null;
            
            switch(period) {
                case 'today':
                    periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    // Get the first day of the current week (Sunday is the first day)
                    periodStart = new Date(now);
                    periodStart.setDate(now.getDate() - now.getDay());
                    periodStart.setHours(0, 0, 0, 0);
                    break;
                case 'month':
                    periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
                default: // 'all'
                    periodStart = null;
            }
            
            // Create query with period filter if needed
            let query = db.collection('events').where('type', '==', 'gameCompleted');
            
            if (periodStart) {
                // Need to use orderBy with the timestamp filter
                query = query.where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(periodStart));
            }
            
            // Always order by timestamp for consistent results
            query = query.orderBy('timestamp', 'desc').limit(20);
            
            const gamesQuery = await query.get();
                
            let currentStreak = 0;
            let streakBroken = false;
            
            gamesQuery.forEach(doc => {
                const gameData = doc.data();
                
                if (!streakBroken) {
                    if (gameData.winner === 'player') {
                        currentStreak++;
                    } else {
                        streakBroken = true;
                    }
                }
            });
            
            return currentStreak;
        } catch (error) {
            console.error('Error calculating win streak:', error);
            return 0;
        }
    }
    
    // Get statistics for the stats modal
    async function getStatistics(period = 'all') {
        if (!initialized) {
            await initialize();
        }
        
        if (!initialized) return null; // Return null if initialization failed
        
        try {
            // Basic visit metrics
            const dailyCountsDoc = await db.collection('metrics').doc('daily-counts').get();
            const uniqueCountsDoc = await db.collection('metrics').doc('unique-daily').get();
            
            const dailyCounts = dailyCountsDoc.exists ? dailyCountsDoc.data() : {};
            const uniqueCounts = uniqueCountsDoc.exists ? uniqueCountsDoc.data() : {};
            
            // Calculate totals
            const totalVisits = Object.values(dailyCounts).reduce((sum, count) => sum + count, 0);
            const totalUniques = Object.values(uniqueCounts).reduce((sum, count) => sum + count, 0);
            
            // Get today's counts
            const today = new Date().toISOString().split('T')[0];
            const todayVisits = dailyCounts[today] || 0;
            const todayUniques = uniqueCounts[today] || 0;
            
            // Get time period filter dates
            const now = new Date();
            let periodStart = null;
            
            switch(period) {
                case 'today':
                    periodStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    // Get the first day of the current week (Sunday is the first day)
                    periodStart = new Date(now);
                    periodStart.setDate(now.getDate() - now.getDay());
                    periodStart.setHours(0, 0, 0, 0);
                    break;
                case 'month':
                    periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
                default: // 'all'
                    periodStart = null;
            }
            
            // Get completed games based on the time period
            let query = db.collection('events').where('type', '==', 'gameCompleted');
            
            if (periodStart) {
                // Add timestamp filter if period is specified
                query = query.where('timestamp', '>=', firebase.firestore.Timestamp.fromDate(periodStart));
            }
            
            // Execute the query
            const gamesQuery = await query.get();
                
            const totalGames = gamesQuery.size;
            
            // Process game statistics
            let playerWins = 0;
            let computerWins = 0;
            let ties = 0;
            let playerWinsAsX = 0;
            let playerWinsAsO = 0;
            let playerGamesAsX = 0;
            let playerGamesAsO = 0;
            
            // Advanced performance metrics
            const aiPerformance = {
                // Player as X performance against different AI styles
                playerAsX: {
                    aggressive: { wins: 0, losses: 0, ties: 0, total: 0 },
                    defensive: { wins: 0, losses: 0, ties: 0, total: 0 },
                    balanced: { wins: 0, losses: 0, ties: 0, total: 0 },
                    random: { wins: 0, losses: 0, ties: 0, total: 0 }
                },
                // Player as O performance against different AI styles
                playerAsO: {
                    aggressive: { wins: 0, losses: 0, ties: 0, total: 0 },
                    defensive: { wins: 0, losses: 0, ties: 0, total: 0 },
                    balanced: { wins: 0, losses: 0, ties: 0, total: 0 },
                    random: { wins: 0, losses: 0, ties: 0, total: 0 }
                }
            };
            
            // AI style performance
            let aggressiveTotal = 0;
            let aggressiveWins = 0;
            let defensiveTotal = 0;
            let defensiveWins = 0;
            let balancedTotal = 0;
            let balancedWins = 0;
            let randomTotal = 0;
            let randomWins = 0;
            
            gamesQuery.forEach(doc => {
                const gameData = doc.data();
                
                // Track player symbol data
                const playerSymbol = gameData.playerSymbol || "";
                if (playerSymbol === 'X') {
                    playerGamesAsX++;
                } else if (playerSymbol === 'O') {
                    playerGamesAsO++;
                }
                
                // Count outcomes
                if (gameData.winner === 'player') {
                    playerWins++;
                    
                    // Track symbol
                    if (playerSymbol === 'X') {
                        playerWinsAsX++;
                    } else if (playerSymbol === 'O') {
                        playerWinsAsO++;
                    }
                } else if (gameData.winner === 'computer') {
                    computerWins++;
                } else {
                    ties++;
                }
                
                // Track AI style performance if available
                const aiStyle = gameData.aiStyle || 'random';
                
                // Update the detailed stats
                if (playerSymbol && aiStyle) {
                    const symbolKey = playerSymbol === 'X' ? 'playerAsX' : 'playerAsO';
                    
                    // Ensure the style exists in our tracker
                    if (!aiPerformance[symbolKey][aiStyle]) {
                        aiPerformance[symbolKey][aiStyle] = { wins: 0, losses: 0, ties: 0, total: 0 };
                    }
                    
                    // Update counts
                    aiPerformance[symbolKey][aiStyle].total++;
                    
                    if (gameData.winner === 'player') {
                        aiPerformance[symbolKey][aiStyle].wins++;
                    } else if (gameData.winner === 'computer') {
                        aiPerformance[symbolKey][aiStyle].losses++;
                    } else {
                        aiPerformance[symbolKey][aiStyle].ties++;
                    }
                }
                
                // Update the overall AI style statistics
                if (aiStyle) {
                    switch (aiStyle) {
                        case 'aggressive':
                            aggressiveTotal++;
                            if (gameData.winner === 'computer') aggressiveWins++;
                            break;
                        case 'defensive':
                            defensiveTotal++;
                            if (gameData.winner === 'computer') defensiveWins++;
                            break;
                        case 'balanced':
                            balancedTotal++;
                            if (gameData.winner === 'computer') balancedWins++;
                            break;
                        case 'random':
                            randomTotal++;
                            if (gameData.winner === 'computer') randomWins++;
                            break;
                    }
                }
            });
            
            // Calculate win rates
            const playerWinRate = totalGames > 0 ? (playerWins / totalGames * 100).toFixed(1) : 0;
            const computerWinRate = totalGames > 0 ? (computerWins / totalGames * 100).toFixed(1) : 0;
            const tieRate = totalGames > 0 ? (ties / totalGames * 100).toFixed(1) : 0;
            
            // Calculate symbol win rates
            const playerWinRateAsX = playerGamesAsX > 0 ? (playerWinsAsX / playerGamesAsX * 100).toFixed(1) : 0;
            const playerWinRateAsO = playerGamesAsO > 0 ? (playerWinsAsO / playerGamesAsO * 100).toFixed(1) : 0;
            
            // Calculate AI style win rates
            const aggressiveWinRate = aggressiveTotal > 0 ? (aggressiveWins / aggressiveTotal * 100).toFixed(1) : 0;
            const defensiveWinRate = defensiveTotal > 0 ? (defensiveWins / defensiveTotal * 100).toFixed(1) : 0;
            const balancedWinRate = balancedTotal > 0 ? (balancedWins / balancedTotal * 100).toFixed(1) : 0;
            const randomWinRate = randomTotal > 0 ? (randomWins / randomTotal * 100).toFixed(1) : 0;
            
            // Calculate detailed win rates for each combination
            for (const symbolKey in aiPerformance) {
                for (const aiStyle in aiPerformance[symbolKey]) {
                    const stats = aiPerformance[symbolKey][aiStyle];
                    if (stats.total > 0) {
                        stats.winRate = (stats.wins / stats.total * 100).toFixed(1);
                    } else {
                        stats.winRate = "0.0";
                    }
                }
            }
            
            // Calculate win streak for the selected time period
            const winStreak = await calculateWinStreak(period);
            
            return {
                // Site metrics
                totalVisits,
                totalUniques,
                todayVisits,
                todayUniques,
                
                // Win streak
                winStreak,
                
                // Game metrics
                totalGames,
                playerWins,
                computerWins,
                ties,
                playerWinRate,
                computerWinRate,
                tieRate,
                
                // Symbol performance
                playerWinsAsX,
                playerWinsAsO,
                playerGamesAsX,
                playerGamesAsO,
                playerWinRateAsX,
                playerWinRateAsO,
                
                // Detailed AI style performance by player symbol
                aiPerformance,
                
                // AI style performance
                aggressiveTotal,
                aggressiveWins,
                aggressiveWinRate,
                defensiveTotal,
                defensiveWins,
                defensiveWinRate,
                balancedTotal,
                balancedWins,
                balancedWinRate,
                randomTotal,
                randomWins,
                randomWinRate
            };
        } catch (error) {
            console.error('Error fetching statistics:', error);
            return null;
        }
    }
    
    // Public API
    return {
        initialize,
        trackPageView,
        trackGameEvent,
        calculateWinStreak,
        getStatistics
    };
})();